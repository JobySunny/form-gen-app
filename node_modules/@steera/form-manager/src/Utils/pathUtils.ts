/**
 * Unique Path Key to identify a Component
 */
export enum ComponentPath {
  box = 'box',
  addnew = 'addnew',
  textbox = 'textbox',
  fieldset = 'fieldset',
  emailbox = 'emailbox',
  radiobox = 'radiobox',
  checkbox = 'checkbox',
  selectbox = 'selectbox',
  numberbox = 'numberbox',
  passwordbox = 'passwordbox',
  flexrow = 'flexrow',
  flexcolumn = 'flexcolumn'
}

/**
 * PATH:
 * A path is a string that when parsed could give you a unique
 * pathway to a particular element in template object
 *
 * Eg: '0-flexcolumn/0-flexrow/0-addnew'
 *  - This path points to the ADD_NEW component, that is sitting inside a
 *   flexrow component which is sitting inside a flewcolumn component
 *
 *  '0-flexcolumn':
 *  * the FLEX_COLUMN component is sitting in the 0th index of its parent component
 *  '0-flexrow':
 *  * the FLEX_ROW component is sitting in the 0th index of its parent component
 *  '0-addnew':
 *  * the ADD_NEW component is sitting in the 0th index of its parent component
 *
 * pathNode
 * A single path entity separated by INDEX_COMPONENT_DELIMITER { default '-'}
 * Eg: '0-addnew'
 *
 * Path.indexDelimiter
 * A separator for index of item in children array and ComponentPath
 *
 * Path.nodeDelimiter
 * A separator between 2 PATH NODE's
 *
 */

export type Index = number | string;
export type PathKey = string;
export type IndexDelimiter = string;
export type NodeDelimiter = string;
export type PathNode = string;
export type PathType = string;

export class Path {
  private static readonly indexDelimiter: IndexDelimiter = '-';
  private static readonly nodeDelimiter: NodeDelimiter = '/';

  /**
   * makePathNode
   *  Creates a single pathNode Entity
   */
  static makePathNode(pathKey: PathKey, index: Index): PathNode {
    return [index, pathKey].join(Path.indexDelimiter);
  }

  /**
   * makePath
   *  Add a new node to existing Path
   */
  static addNodeToPath(currentPath: PathType, pathNode: PathNode): PathType {
    const newPath = [currentPath, pathNode].join(Path.nodeDelimiter);
    /** if first character is nodeDemimiter **/
    if (newPath.slice(0, 1) === Path.nodeDelimiter) {
      return newPath.slice(1);
    } else {
      return newPath;
    }
  }

  /**
   * parseToNodes
   *  parse full path to pathNodes
   */
  static parseToNodes(currentPath: PathType): Array<PathNode> {
    return currentPath.split(Path.nodeDelimiter).filter((node) => node.length);
  }

  /**
   * parseToIndex
   *  parse pathNode to index & ComponentPath
   */
  static parseToIndex(pathNode: PathNode): [Index, PathKey] {
    const [index, pathKey] = pathNode.split(Path.indexDelimiter);
    return [index, pathKey];
  }

  /**
   * parseFullPath
   *  parse a path to Path[ PathNode[Index,PathKey], PathNode[Index, PathKey]]
   */
  static parseFullPath(currentPath: PathType): Array<[Index, PathKey]> {
    return Path.parseToNodes(currentPath).map(Path.parseToIndex);
  }

  /**
   * mergePathNodes
   *  merge PathNodes[] to Path
   */
  static mergePathNodes(pathNodes: Array<PathNode>): PathType {
    return pathNodes.join(Path.nodeDelimiter);
  }

  /**
   * getSelectedPathKey
   *  get the pathKey of selected element in selecteElementPath
   */
  static getSelectedPathKey(currentPath: PathType): PathKey {
    const parsedFullPath = Path.parseFullPath(currentPath);
    if (parsedFullPath.length) {
      return parsedFullPath[parsedFullPath.length - 1][1];
    } else {
      return '';
    }
  }
}
