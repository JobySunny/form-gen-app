var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as React from 'react';
import { Wrap } from './Wrap';
import { Icon } from './Icon';
import { Content } from './Content';
import { Options } from './Options';
import { SelectTag } from './SelectTag';
import { InputBlock } from './InputBlock';
import { DELAY } from './Select.constants';
import { getThrottle as getDelay } from './Select.utils';
import cn from './Select.module.scss';
/**
 * Select
 *  Custom Select component for Async operations
 */
export function Select(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const [state, setState] = React.useState({
        focused: false,
        options: [],
        loading: false,
        showOptions: false,
    });
    const delay = getDelay('onBlurDelay');
    const onSearch = (searchText) => __awaiter(this, void 0, void 0, function* () {
        setState((s) => (Object.assign(Object.assign({}, s), { loading: true, showOptions: true })));
        try {
            const options = yield props.onSearch(searchText);
            setState((s) => (Object.assign(Object.assign({}, s), { loading: false, options })));
        }
        catch (error) {
            setState((s) => (Object.assign(Object.assign({}, s), { loading: false, options: [] })));
        }
    });
    const onFocus = (target) => {
        setState((s) => (Object.assign(Object.assign({}, s), { focused: true })));
        (props === null || props === void 0 ? void 0 : props.onFocus) && props.onFocus(target);
    };
    const onBlur = (target) => {
        delay(() => {
            setState((s) => (Object.assign(Object.assign({}, s), { focused: false, showOptions: false })));
            (props === null || props === void 0 ? void 0 : props.onBlur) && props.onBlur(target);
        }, DELAY);
    };
    const onSelect = (option) => {
        props.onSelect({ name: props.name, value: option });
        delay(() => {
            setState((s) => (Object.assign(Object.assign({}, s), { showOptions: false })));
        }, DELAY);
    };
    const getClassName = (selector = '') => {
        return `${cn[`sel${selector}`]} ${props.className}${selector}`;
    };
    return (_jsxs(Wrap, Object.assign({ testId: (_a = props.testId) !== null && _a !== void 0 ? _a : '', onFocus: onFocus, onBlur: onBlur, className: getClassName(''), disabled: (_b = props.disabled) !== null && _b !== void 0 ? _b : false }, { children: [_jsxs(Content, Object.assign({ className: getClassName('_main') }, { children: [_jsx(SelectTag, { name: props.name, id: props.id, testId: (_c = props.testId) !== null && _c !== void 0 ? _c : '', options: state.options, value: (_d = props.value) === null || _d === void 0 ? void 0 : _d.value, disabled: props.disabled, required: props.required, className: getClassName('_main__tag') }), _jsx(InputBlock, { focused: state.focused, value: (_e = props.value) === null || _e === void 0 ? void 0 : _e.label, onSearch: onSearch, testId: (_f = props.testId) !== null && _f !== void 0 ? _f : '', disabled: props.disabled, placeholder: (_g = props.placeholder) !== null && _g !== void 0 ? _g : '', className: getClassName('_main__input') }), _jsx(Icon, { focus: state.focused, loading: state.loading, testId: (_h = props.testId) !== null && _h !== void 0 ? _h : '', className: getClassName('_main__iconBlock'), iconClassName: getClassName('_main__iconBlock_item') })] })), _jsx(Options, { show: state.showOptions, testId: (_j = props.testId) !== null && _j !== void 0 ? _j : '', className: getClassName('_options'), options: state.options, loading: state.loading, onSelect: onSelect, optionClass: getClassName('_options__item') })] })));
}
//# sourceMappingURL=Select.js.map