"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = exports.ComponentPath = void 0;
/**
 * Unique Path Key to identify a Component
 */
var ComponentPath;
(function (ComponentPath) {
    ComponentPath["box"] = "box";
    ComponentPath["addnew"] = "addnew";
    ComponentPath["textbox"] = "textbox";
    ComponentPath["fieldset"] = "fieldset";
    ComponentPath["emailbox"] = "emailbox";
    ComponentPath["radiobox"] = "radiobox";
    ComponentPath["checkbox"] = "checkbox";
    ComponentPath["selectbox"] = "selectbox";
    ComponentPath["numberbox"] = "numberbox";
    ComponentPath["passwordbox"] = "passwordbox";
    ComponentPath["flexrow"] = "flexrow";
    ComponentPath["flexcolumn"] = "flexcolumn";
})(ComponentPath = exports.ComponentPath || (exports.ComponentPath = {}));
class Path {
    /**
     * makePathNode
     *  Creates a single pathNode Entity
     */
    static makePathNode(pathKey, index) {
        return [index, pathKey].join(Path.indexDelimiter);
    }
    /**
     * makePath
     *  Add a new node to existing Path
     */
    static addNodeToPath(currentPath, pathNode) {
        const newPath = [currentPath, pathNode].join(Path.nodeDelimiter);
        /** if first character is nodeDemimiter **/
        if (newPath.slice(0, 1) === Path.nodeDelimiter) {
            return newPath.slice(1);
        }
        else {
            return newPath;
        }
    }
    /**
     * parseToNodes
     *  parse full path to pathNodes
     */
    static parseToNodes(currentPath) {
        return currentPath.split(Path.nodeDelimiter).filter((node) => node.length);
    }
    /**
     * parseToIndex
     *  parse pathNode to index & ComponentPath
     */
    static parseToIndex(pathNode) {
        const [index, pathKey] = pathNode.split(Path.indexDelimiter);
        return [index, pathKey];
    }
    /**
     * parseFullPath
     *  parse a path to Path[ PathNode[Index,PathKey], PathNode[Index, PathKey]]
     */
    static parseFullPath(currentPath) {
        return Path.parseToNodes(currentPath).map(Path.parseToIndex);
    }
    /**
     * mergePathNodes
     *  merge PathNodes[] to Path
     */
    static mergePathNodes(pathNodes) {
        return pathNodes.join(Path.nodeDelimiter);
    }
    /**
     * getSelectedPathKey
     *  get the pathKey of selected element in selecteElementPath
     */
    static getSelectedPathKey(currentPath) {
        const parsedFullPath = Path.parseFullPath(currentPath);
        if (parsedFullPath.length) {
            return parsedFullPath[parsedFullPath.length - 1][1];
        }
        else {
            return '';
        }
    }
}
exports.Path = Path;
Path.indexDelimiter = '-';
Path.nodeDelimiter = '/';
//# sourceMappingURL=pathUtils.js.map