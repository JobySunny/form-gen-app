{"ast":null,"code":"/**\n * Unique Path Key to identify a Component\n */\nexport var ComponentPath;\n\n(function (ComponentPath) {\n  ComponentPath[\"box\"] = \"box\";\n  ComponentPath[\"addnew\"] = \"addnew\";\n  ComponentPath[\"textbox\"] = \"textbox\";\n  ComponentPath[\"fieldset\"] = \"fieldset\";\n  ComponentPath[\"emailbox\"] = \"emailbox\";\n  ComponentPath[\"radiobox\"] = \"radiobox\";\n  ComponentPath[\"checkbox\"] = \"checkbox\";\n  ComponentPath[\"selectbox\"] = \"selectbox\";\n  ComponentPath[\"numberbox\"] = \"numberbox\";\n  ComponentPath[\"passwordbox\"] = \"passwordbox\";\n  ComponentPath[\"flexrow\"] = \"flexrow\";\n  ComponentPath[\"flexcolumn\"] = \"flexcolumn\";\n})(ComponentPath || (ComponentPath = {}));\n\nexport class Path {\n  /**\n   * makePathNode\n   *  Creates a single pathNode Entity\n   */\n  static makePathNode(pathKey, index) {\n    return [index, pathKey].join(Path.indexDelimiter);\n  }\n  /**\n   * makePath\n   *  Add a new node to existing Path\n   */\n\n\n  static addNodeToPath(currentPath, pathNode) {\n    const newPath = [currentPath, pathNode].join(Path.nodeDelimiter);\n    /** if first character is nodeDemimiter **/\n\n    if (newPath.slice(0, 1) === Path.nodeDelimiter) {\n      return newPath.slice(1);\n    } else {\n      return newPath;\n    }\n  }\n  /**\n   * parseToNodes\n   *  parse full path to pathNodes\n   */\n\n\n  static parseToNodes(currentPath) {\n    return currentPath.split(Path.nodeDelimiter).filter(node => node.length);\n  }\n  /**\n   * parseToIndex\n   *  parse pathNode to index & ComponentPath\n   */\n\n\n  static parseToIndex(pathNode) {\n    const [index, pathKey] = pathNode.split(Path.indexDelimiter);\n    return [index, pathKey];\n  }\n  /**\n   * parseFullPath\n   *  parse a path to Path[ PathNode[Index,PathKey], PathNode[Index, PathKey]]\n   */\n\n\n  static parseFullPath(currentPath) {\n    return Path.parseToNodes(currentPath).map(Path.parseToIndex);\n  }\n  /**\n   * mergePathNodes\n   *  merge PathNodes[] to Path\n   */\n\n\n  static mergePathNodes(pathNodes) {\n    return pathNodes.join(Path.nodeDelimiter);\n  }\n  /**\n   * getSelectedPathKey\n   *  get the pathKey of selected element in selecteElementPath\n   */\n\n\n  static getSelectedPathKey(currentPath) {\n    const parsedFullPath = Path.parseFullPath(currentPath);\n\n    if (parsedFullPath.length) {\n      return parsedFullPath[parsedFullPath.length - 1][1];\n    } else {\n      return '';\n    }\n  }\n\n}\nPath.indexDelimiter = '-';\nPath.nodeDelimiter = '/';","map":{"version":3,"mappings":"AAAA;;;AAGA,WAAYA,aAAZ;;AAAA,WAAYA,aAAZ,EAAyB;EACvBA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;AACD,CAbD,EAAYA,aAAa,KAAbA,aAAa,MAAzB;;AAkDA,OAAM,MAAOC,IAAP,CAAW;EAIf;;;;EAImB,OAAZC,YAAY,CAACC,OAAD,EAAmBC,KAAnB,EAA+B;IAChD,OAAO,CAACA,KAAD,EAAQD,OAAR,EAAiBE,IAAjB,CAAsBJ,IAAI,CAACK,cAA3B,CAAP;EACD;EAED;;;;;;EAIoB,OAAbC,aAAa,CAACC,WAAD,EAAwBC,QAAxB,EAA0C;IAC5D,MAAMC,OAAO,GAAG,CAACF,WAAD,EAAcC,QAAd,EAAwBJ,IAAxB,CAA6BJ,IAAI,CAACU,aAAlC,CAAhB;IACA;;IACA,IAAID,OAAO,CAACE,KAAR,CAAc,CAAd,EAAiB,CAAjB,MAAwBX,IAAI,CAACU,aAAjC,EAAgD;MAC9C,OAAOD,OAAO,CAACE,KAAR,CAAc,CAAd,CAAP;IACD,CAFD,MAEO;MACL,OAAOF,OAAP;IACD;EACF;EAED;;;;;;EAImB,OAAZG,YAAY,CAACL,WAAD,EAAsB;IACvC,OAAOA,WAAW,CAACM,KAAZ,CAAkBb,IAAI,CAACU,aAAvB,EAAsCI,MAAtC,CAA8CC,IAAD,IAAUA,IAAI,CAACC,MAA5D,CAAP;EACD;EAED;;;;;;EAImB,OAAZC,YAAY,CAACT,QAAD,EAAmB;IACpC,MAAM,CAACL,KAAD,EAAQD,OAAR,IAAmBM,QAAQ,CAACK,KAAT,CAAeb,IAAI,CAACK,cAApB,CAAzB;IACA,OAAO,CAACF,KAAD,EAAQD,OAAR,CAAP;EACD;EAED;;;;;;EAIoB,OAAbgB,aAAa,CAACX,WAAD,EAAsB;IACxC,OAAOP,IAAI,CAACY,YAAL,CAAkBL,WAAlB,EAA+BY,GAA/B,CAAmCnB,IAAI,CAACiB,YAAxC,CAAP;EACD;EAED;;;;;;EAIqB,OAAdG,cAAc,CAACC,SAAD,EAA2B;IAC9C,OAAOA,SAAS,CAACjB,IAAV,CAAeJ,IAAI,CAACU,aAApB,CAAP;EACD;EAED;;;;;;EAIyB,OAAlBY,kBAAkB,CAACf,WAAD,EAAsB;IAC7C,MAAMgB,cAAc,GAAGvB,IAAI,CAACkB,aAAL,CAAmBX,WAAnB,CAAvB;;IACA,IAAIgB,cAAc,CAACP,MAAnB,EAA2B;MACzB,OAAOO,cAAc,CAACA,cAAc,CAACP,MAAf,GAAwB,CAAzB,CAAd,CAA0C,CAA1C,CAAP;IACD,CAFD,MAEO;MACL,OAAO,EAAP;IACD;EACF;;AAtEc;AACShB,sBAAiC,GAAjC;AACAA,qBAA+B,GAA/B","names":["ComponentPath","Path","makePathNode","pathKey","index","join","indexDelimiter","addNodeToPath","currentPath","pathNode","newPath","nodeDelimiter","slice","parseToNodes","split","filter","node","length","parseToIndex","parseFullPath","map","mergePathNodes","pathNodes","getSelectedPathKey","parsedFullPath"],"sources":["/home/fact-11/Desktop/formApp/formapp/node_modules/@steera/form-manager/src/Utils/pathUtils.ts"],"sourcesContent":["/**\n * Unique Path Key to identify a Component\n */\nexport enum ComponentPath {\n  box = 'box',\n  addnew = 'addnew',\n  textbox = 'textbox',\n  fieldset = 'fieldset',\n  emailbox = 'emailbox',\n  radiobox = 'radiobox',\n  checkbox = 'checkbox',\n  selectbox = 'selectbox',\n  numberbox = 'numberbox',\n  passwordbox = 'passwordbox',\n  flexrow = 'flexrow',\n  flexcolumn = 'flexcolumn'\n}\n\n/**\n * PATH:\n * A path is a string that when parsed could give you a unique\n * pathway to a particular element in template object\n *\n * Eg: '0-flexcolumn/0-flexrow/0-addnew'\n *  - This path points to the ADD_NEW component, that is sitting inside a\n *   flexrow component which is sitting inside a flewcolumn component\n *\n *  '0-flexcolumn':\n *  * the FLEX_COLUMN component is sitting in the 0th index of its parent component\n *  '0-flexrow':\n *  * the FLEX_ROW component is sitting in the 0th index of its parent component\n *  '0-addnew':\n *  * the ADD_NEW component is sitting in the 0th index of its parent component\n *\n * pathNode\n * A single path entity separated by INDEX_COMPONENT_DELIMITER { default '-'}\n * Eg: '0-addnew'\n *\n * Path.indexDelimiter\n * A separator for index of item in children array and ComponentPath\n *\n * Path.nodeDelimiter\n * A separator between 2 PATH NODE's\n *\n */\n\nexport type Index = number | string;\nexport type PathKey = string;\nexport type IndexDelimiter = string;\nexport type NodeDelimiter = string;\nexport type PathNode = string;\nexport type PathType = string;\n\nexport class Path {\n  private static readonly indexDelimiter: IndexDelimiter = '-';\n  private static readonly nodeDelimiter: NodeDelimiter = '/';\n\n  /**\n   * makePathNode\n   *  Creates a single pathNode Entity\n   */\n  static makePathNode(pathKey: PathKey, index: Index): PathNode {\n    return [index, pathKey].join(Path.indexDelimiter);\n  }\n\n  /**\n   * makePath\n   *  Add a new node to existing Path\n   */\n  static addNodeToPath(currentPath: PathType, pathNode: PathNode): PathType {\n    const newPath = [currentPath, pathNode].join(Path.nodeDelimiter);\n    /** if first character is nodeDemimiter **/\n    if (newPath.slice(0, 1) === Path.nodeDelimiter) {\n      return newPath.slice(1);\n    } else {\n      return newPath;\n    }\n  }\n\n  /**\n   * parseToNodes\n   *  parse full path to pathNodes\n   */\n  static parseToNodes(currentPath: PathType): Array<PathNode> {\n    return currentPath.split(Path.nodeDelimiter).filter((node) => node.length);\n  }\n\n  /**\n   * parseToIndex\n   *  parse pathNode to index & ComponentPath\n   */\n  static parseToIndex(pathNode: PathNode): [Index, PathKey] {\n    const [index, pathKey] = pathNode.split(Path.indexDelimiter);\n    return [index, pathKey];\n  }\n\n  /**\n   * parseFullPath\n   *  parse a path to Path[ PathNode[Index,PathKey], PathNode[Index, PathKey]]\n   */\n  static parseFullPath(currentPath: PathType): Array<[Index, PathKey]> {\n    return Path.parseToNodes(currentPath).map(Path.parseToIndex);\n  }\n\n  /**\n   * mergePathNodes\n   *  merge PathNodes[] to Path\n   */\n  static mergePathNodes(pathNodes: Array<PathNode>): PathType {\n    return pathNodes.join(Path.nodeDelimiter);\n  }\n\n  /**\n   * getSelectedPathKey\n   *  get the pathKey of selected element in selecteElementPath\n   */\n  static getSelectedPathKey(currentPath: PathType): PathKey {\n    const parsedFullPath = Path.parseFullPath(currentPath);\n    if (parsedFullPath.length) {\n      return parsedFullPath[parsedFullPath.length - 1][1];\n    } else {\n      return '';\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}